#include "cache.h"

// ------------------------- DO NOT CHANGE -------------------------------- //
#define NUM_IP_TABLE_ENTRIES 1024           // IP table entries
#define PREFETCH_DEGREE 5                   // Prefetch degree
// ------------------------- DO NOT CHANGE -------------------------------- //

#define MAX_CONFIDENCE 7                   // Maximum confidence value
#define NUM_CSPT_ENTRIES 1<<8               // CSPT entries


// CSPT Entry
class CSPT_ENTRY {
  public:
    uint8_t signature;
    int stride;
    int conf;
    int counter;

    CSPT_ENTRY() {
        signature = 0;
        stride = 0;
        conf = 0;
        counter = 0;
    }
};


// ------------ YOU CAN CHANGE THE IP_TABLE FOR YOUR DESIGN ---------------- //
class IP_TABLE {
  public:
    uint64_t ip_tag;
    //uint64_t last_page;                     // Last page seen by IP
    //uint64_t last_cl_offset;                // Last cache line offset in the 4KB page
    uint64_t address;
    //int64_t last_stride;                    // Last delta observed
    uint16_t ip_valid;                      // Valid IP or not   
    uint8_t signature;                     // CPLX signature
    int counter;
    CSPT_ENTRY cspt[NUM_CSPT_ENTRIES];

    IP_TABLE () {
        ip_tag = 0;
        //last_page = 0;
        //last_cl_offset = 0;
        address=0;
        //last_stride = 0;
        ip_valid = 0;
        signature = 0;
        counter = 0;
        // Initialize CSPT
        for (int i = 0; i < NUM_CSPT_ENTRIES; i++) {
            cspt[i] = CSPT_ENTRY();
        }
    };
};


IP_TABLE trackers_cplx[NUM_CPUS][NUM_IP_TABLE_ENTRIES];
//CSPT_ENTRY cspt[NUM_CPUS][NUM_CSPT_ENTRIES];

// ------------------------- Updating the signature ---------------------------- // 
uint8_t update_sig_l1(uint8_t old_sig, int delta) {                           
    uint8_t new_sig = ((old_sig << 1) ^ (uint16_t)delta);
    return new_sig;
}

// ------------------- Updating confidence for the CPLX class ------------------ // 
int update_conf(int stride, int pred_stride, int conf) {
    if (stride == pred_stride) {
        if (conf < MAX_CONFIDENCE)
            conf++;
    } else {
        if (conf > 0)
            conf--;
    }
    return conf;
}

// ------------------------- Initialize the prefetcher ------------------------- // 
void CACHE::l1d_prefetcher_initialize() 
{
    cout << "CPU " << cpu << " L1D Complex-Stride prefetcher" << endl;
    // Initialize IP Table
    for (int i = 0; i < NUM_IP_TABLE_ENTRIES; i++) {
        trackers_cplx[cpu][i] = IP_TABLE();
    }
}

// --------------- This is the main prefetcher operate function ---------------- // 
void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint8_t critical_ip_flag)
{
    uint64_t cl_addr = (addr >> LOG2_BLOCK_SIZE);
    //uint64_t page_number = addr >> LOG2_PAGE_SIZE;
    //uint64_t cl_offset = (cl_addr) & ((1 << (12 - LOG2_BLOCK_SIZE)) - 1); // bits 6-11

    bool is_present1=0;
    int index1=-1;
    for(int i=0;i<NUM_IP_TABLE_ENTRIES;i++){
        if(trackers_cplx[cpu][i].ip_tag!=0)
            trackers_cplx[cpu][i].counter++;
        if(trackers_cplx[cpu][i].ip_tag==ip){
            index1=i;
            is_present1=1;
            trackers_cplx[cpu][i].counter=0;
        }
    }
    if(is_present1){
        bool is_present2=1;
        int index2=-1;
        if (((addr) >> LOG2_PAGE_SIZE) != (trackers_cplx[cpu][index1].address >> LOG2_PAGE_SIZE)) {
            trackers_cplx[cpu][index1].address = addr;
            return;
        }
        int new_stride=cl_addr-(trackers_cplx[cpu][index1].address >> LOG2_BLOCK_SIZE);
        
        index2 = trackers_cplx[cpu][index1].signature;
    
        //cout << "Hi1" << endl;
        int confidence = update_conf(new_stride,trackers_cplx[cpu][index1].cspt[index2].stride, trackers_cplx[cpu][index1].cspt[index2].conf);
        trackers_cplx[cpu][index1].cspt[index2].conf=confidence;
        uint8_t new_signature=update_sig_l1(trackers_cplx[cpu][index1].signature,new_stride);
        trackers_cplx[cpu][index1].signature=new_signature;
        if(confidence==0){
            trackers_cplx[cpu][index1].cspt[index2].stride=new_stride;
        }
        //int stride_to_prefetch=0;
        int stride_for_prefetch=-1;
        int confidence_for_prefetch=0;

        stride_for_prefetch = trackers_cplx[cpu][index1].cspt[new_signature].stride;
        confidence_for_prefetch = trackers_cplx[cpu][index1].cspt[new_signature].conf;
        
        if (stride_for_prefetch != 0 && confidence_for_prefetch!=0) {
            for (int i=1; i<=PREFETCH_DEGREE; i++) {
                if ((addr)>>LOG2_PAGE_SIZE == (trackers_cplx[cpu][index1].address >> LOG2_PAGE_SIZE)) {
                    prefetch_line(ip, addr, ((cl_addr + stride_for_prefetch*i) << LOG2_BLOCK_SIZE), FILL_L1, 0);
                }
                else {
                    break;
                }
            }
        }
    
    }
    else{
        srand(time(0));
        int index=-1; 
        int maximum=-1;
        int flag=0;
        for(int i=0;i<NUM_IP_TABLE_ENTRIES;i++){
            if(trackers_cplx[cpu][i].ip_tag==0){
                index=i;
                flag=1;
                break;
            }
            // if(trackers_cplx[cpu][i].counter>maximum){
            //     maximum=trackers_cplx[cpu][i].counter;
            //     index=i;
            // }
        }
        if(flag==0){
            index=rand()% NUM_IP_TABLE_ENTRIES;//Random Replacement Policy
        }
        trackers_cplx[cpu][index].ip_tag=ip;
        trackers_cplx[cpu][index].address=addr;
        trackers_cplx[cpu][index].ip_valid=1;
        trackers_cplx[cpu][index].signature=0;//signature always starts from zero
        trackers_cplx[cpu][index].counter=0;
        for (int i = 0; i < NUM_CSPT_ENTRIES; i++) {
            trackers_cplx[cpu][index].cspt[i] = CSPT_ENTRY();
        }
    }
}

// ------------------------- DO NOT CHANGE -------------------------------- //
void CACHE::l1d_prefetcher_notify_about_dtlb_eviction(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, uint64_t evicted_addr, uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " L1D complex stride prefetcher final stats" << endl;
    cout << "Degree: " << PREFETCH_DEGREE << endl;
}
// ------------------------- DO NOT CHANGE -------------------------------- //